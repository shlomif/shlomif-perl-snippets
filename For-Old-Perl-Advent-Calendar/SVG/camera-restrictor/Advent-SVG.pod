=head1 The SVG CPAN Module

=head2 Introduction

SVG stands for Scalable Vector Graphics and is an XML-based W3C standard for
vector graphics, animations, and interactive applets. The L<SVG> module
on CPAN provides a convenient interface for generating SVG files from
Perl.

When I started learning programming using BASIC on a PC XT, I followed
a series of booklets that were available in Israel. One of their exercises
involved constructing a series of polygons one inside the other so that the
corners of each polygons were at a proportion of the corners of the previous
one. (Similar to a camera's diaphragm).

Today we'll draw such images using Perl and the SVG module.

=head2 Representing and Managing the Polygons

We'll represent the polygons using an array of B<(x,y)> coordinates. Each
coordinate will be represented as an array reference of two elements, the B<x>
and the B<y>.

In order to transform the old coordinates to the new one, we'll apply the
proportion equation (B<(1-p)*x0+p*x1>) to each two consecutive coordinates
(with the consecutive coordinate of the last one being the first). So we get:

    sub get_new_coords
    {
        my ($coords_ref, $p) = @_;

        # To eliminate some pesky arrows
        my @coords = @$coords_ref;

        return [
            map
            {
                [
                    (1-$p)*$coords[$_][0]+$p*$coords[($_+1)%@coords][0],
                    (1-$p)*$coords[$_][1]+$p*$coords[($_+1)%@coords][1],
                ]
            }
            (0 .. $#coords)
            ];
    }

=head2 Generating a series of shapes.

We'll use the SVG.pm C<get_path()> method to generate the values for the
so-called polyline path, which is suitable for polygons. We need to append the
first coordinate to the end of the coordinates so the polygon will be closed.
After C<get_path()> is invoked, we can pass its return values to the
C<polyline()> method to actually get the B<E<lt>polyline /E<gt>> tag.

The generation function for the effect accepts the following parameters:

=over 4

=item * $id_base

This is a unique base identifier for the C<id=""> attribute of the shapes
generated by the function.

=item * $init_coords

The initial coordinates of the shape as an array reference.

=item * $max_depth

How many internal shapes to generate.

=item * $p

The proportion to use for the effect.

=item * $style_cb

This callback accepts the current depth and should return the CSS style
that should be used by the current iteration.

=back

One should note that for this demonstration the SVG object (called C<$svg>)
will be a global variable.

After we rendered the C<E<lt>polyline /E<gt>> of each step we'll convert
the current coordinates to the new ones using the function in the previous
section. So the complete function looks like this:

    sub mygen
    {
        my ($id_base, $init_coords, $max_depth, $p, $style_cb) = @_;

        my $coords = $init_coords;

        foreach my $depth (0 .. ($max_depth-1))
        {
            my @path_coords = (@$coords, $coords->[0]);

            # Draw the path
            my $path_points =
                $svg->get_path(
                    x => [map { $_->[0]} @path_coords],
                    y => [map { $_->[1]} @path_coords],
                    -type=>'polyline',
                    -closed=>'true',
                );

            $svg->polyline(
                %$path_points,
                id => "${id_base}_$depth",
                style => $style_cb->($depth),
            );
        }
        continue
        {
            $coords = get_new_coords($coords, $p);
        }
    }

=head2 Putting it all together

Now, let's combine the two functions along with some initialization and output
code to generate such an effect starting from a simple square. So the complete
script looks like that:

    #!/usr/bin/perl

    use strict;
    use warnings;

    use SVG;
    use Math::Trig;

    my $max_depth = 50;
    my $proportion = 0.1;

    my $width = 300;
    my $height = $width;

    my $half_width = $width*0.5;
    my $half_height = $height*0.5;

    my $svg = SVG->new(width=>$width, height=>$height,);

    sub get_new_coords
    {
        my ($coords_ref, $p) = @_;

        # To eliminate some pesky arrows
        my @coords = @$coords_ref;

        return [
            map
            {
                [
                    (1-$p)*$coords[$_][0]+$p*$coords[($_+1)%@coords][0],
                    (1-$p)*$coords[$_][1]+$p*$coords[($_+1)%@coords][1],
                ]
            }
            (0 .. $#coords)
            ];
    }

    sub mygen
    {
        my ($id_base, $init_coords, $max_depth, $p, $style_cb) = @_;

        my $coords = $init_coords;

        foreach my $depth (0 .. ($max_depth-1))
        {
            my @path_coords = (@$coords, $coords->[0]);

            # Draw the path
            my $path_points =
                $svg->get_path(
                    x => [map { $_->[0]} @path_coords],
                    y => [map { $_->[1]} @path_coords],
                    -type=>'polyline',
                    -closed=>'true',
                );

            $svg->polyline(
                %$path_points,
                id => "${id_base}_$depth",
                style => $style_cb->($depth),
            );
        }
        continue
        {
            $coords = get_new_coords($coords, $p);
        }
    }

    sub mystyle
    {
        return
        {
            'fill-opacity' => 0,
            'stroke' => 'black',
            'stroke-width' => "1pt",
            'stroke-opacity' => 1,
        };
    }

    mygen("rect",
          [ [100,100], [200,100], [200,200], [100,200], ],
          30, 0.1, \&mystyle
         );

    my $text = $svg->xmlify(-namespace => "svg");
    # Workaround for Mozilla.
    $text =~ s{xmlns=}{xmlns:svg=};
    open O, ">", "square.svg";
    print O $text;
    close(O);

You can see its output in SVG format here:

L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/square.svg>

And in PNG format as rendered from the SVG by Inkscape:

L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/square.png>

=head2 More complications

Why limit ourselves to squares? We can also generate perfect hexagons. Just
change the lines after all the functions to:

    my @points;
    foreach my $i (0 .. 5)
    {
        my $x = $half_width + cos(deg2rad(60*$i))*($half_width*0.66);
        my $y = $half_height + sin(deg2rad(60*$i))*($half_width*0.66);
        push @points, [$x, $y];
    }

    mygen ("hex", \@points, 20, 0.1, \&mystyle);

    my $text = $svg->xmlify(-namespace => "svg");
    # Workaround for Mozilla.
    $text =~ s{xmlns=}{xmlns:svg=};
    open O, ">", "hex.svg";
    print O $text;
    close(O);

What the loop does is generate the coordinate for a perfect hexagon.

The resultant images can be found here:
L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/hex.svg>
and here:
L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/hex.png>.

Now, since the styles can be customized by over-riding the style callback,
we can have nice colors and translucency effects:

    my @fills = (qw(red green yellow blue orange));

    sub color_style
    {
        my $depth = shift;

        return
        {
            'fill-opacity' => 0.5,
            'fill' => $fills[$depth%@fills],
            'stroke' => 'black',
            'stroke-width' => "1pt",
            'stroke-opacity' => 1,
        };
    }

    my @points;
    foreach my $i (0 .. 5)
    {
        my $x = $half_width + cos(deg2rad(60*$i))*($half_width*0.66);
        my $y = $half_height + sin(deg2rad(60*$i))*($half_width*0.66);
        push @points, [$x, $y];
    }
    mygen ("hex", \@points, 20, 0.1, \&color_style);

    my $text = $svg->xmlify(-namespace => "svg");
    # Workaround for Mozilla.
    $text =~ s{xmlns=}{xmlns:svg=};
    open O, ">", "colors.svg";
    print O $text;
    close(O);

The output of this in SVG format can be found here:
L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/colors.svg>
and in PNG:
L<http://www.shlomifish.org/open-source/perl/advent/2006/SVG/colors.png>. One
can notice the overlay effect of the colors' translucency.

=head2 What's next?

This is just the tip of the iceberg of SVG's power. Other features of SVG
include:

=over 4

=item * Various shapes - circles, rectangles, rounded rectangles, Bezier curves...

=item * Styled Text and Fonts

=item * Animation

=item * Scripting using JavaScript

=back

There's plenty for you to explore if you're the artistic type, and even if
you're not, you can play with SVG with Perl or without it
(see L<http://www.inkscape.org/>).

